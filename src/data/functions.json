[
  {
    "name": "all_players_submitted",
    "description": "Проверяет, подали ли все игроки свои ходы в текущей сессии.",
    "parameters": [
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "BOOLEAN",
    "usage": "SELECT all_players_submitted(1);",
    "exampleReturns": "TRUE",
    "code": "CREATE OR REPLACE FUNCTION all_players_submitted(_session_id INT)\nRETURNS BOOLEAN AS\n$$\nDECLARE\n    submitted_count INT;\n    total_players INT;\nBEGIN\n    -- Считаем количество уникальных игроков, подавших ходы\n    SELECT COUNT(DISTINCT playerid)\n      INTO submitted_count\n      FROM move_submissions\n     WHERE sessionid = _session_id;\n     \n    -- Получаем общее количество игроков в сессии\n    SELECT current_player_count\n      INTO total_players\n      FROM gamesessions\n     WHERE sessionid = _session_id;\n     \n    RETURN (submitted_count = total_players);\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "auto_submit_unplaced_cards",
    "description": "Автоматически подает неразыгранные карты для игроков, которые не сделали ход в сессии.",
    "parameters": [
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT auto_submit_unplaced_cards(1);",
    "exampleReturns": "void",
    "code": "CREATE OR REPLACE FUNCTION auto_submit_unplaced_cards(_session_id INT)\nRETURNS VOID AS\n$$\nDECLARE\n    rec RECORD;\nBEGIN\n    -- Проходим по игрокам, не подавшим ход в этой сессии\n    FOR rec IN \n        SELECT \n            p.playerid, \n            MIN(pc.sessioncardid) AS card_to_submit,\n            (\n              SELECT st.token \n              FROM session_tokens st \n              WHERE st.user_id = p.userid \n              ORDER BY st.created_at DESC \n              LIMIT 1\n            ) AS token_for_player\n        FROM PlayerCards pc\n        JOIN Players p ON pc.playerid = p.playerid\n        WHERE p.sessionid = _session_id\n          AND NOT EXISTS (\n              SELECT 1 \n              FROM move_submissions ms\n              WHERE ms.sessionid = _session_id\n                AND ms.playerid = p.playerid\n          )\n        GROUP BY p.playerid, p.userid\n    LOOP\n        -- Автоматически подаем карту, если игрок еще не сделал ход\n        PERFORM place_card_on_table(rec.token_for_player, _session_id, rec.card_to_submit);\n        RAISE NOTICE 'Автоматически подана карта % для игрока % в сессии %', rec.card_to_submit, rec.playerid, _session_id;\n    END LOOP;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "clear_round_table_cards",
    "description": "Очищает карты на столе, кроме карт категории 'Pudding', после завершения раунда.",
    "parameters": [
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT clear_round_table_cards(1);",
    "exampleReturns": "void",
    "code": "CREATE OR REPLACE FUNCTION clear_round_table_cards(_session_id INT) RETURNS VOID AS $$\nBEGIN\n    -- Удаляем карты со стола, кроме категории 'Pudding'\n    DELETE FROM tablecards\n    USING sessioncards sc, cards c\n    WHERE tablecards.sessioncardid = sc.sessioncardid\n      AND sc.cardid = c.cardid\n      AND sc.sessionid = _session_id\n      AND c.category <> 'Pudding';\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "cleanup_session_cron_jobs",
    "description": "Удаляет запланированные задания cron для указанной сессии.",
    "parameters": [
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT cleanup_session_cron_jobs(1);",
    "exampleReturns": "void",
    "code": "CREATE OR REPLACE FUNCTION cleanup_session_cron_jobs(_session_id INT)\nRETURNS VOID AS $$\nBEGIN\n    -- Удаляем задания cron для сессии\n    DELETE FROM cron.job\n    WHERE jobname = 'session_' || _session_id || '_move_timeout';\n    RAISE NOTICE 'Очищены задания cron для сессии %', _session_id;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_dumpling",
    "description": "Вычисляет очки за карты категории 'Dumpling' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_dumpling(1);",
    "exampleReturns": "playerid: 1, points: 6",
    "code": "CREATE OR REPLACE FUNCTION compute_dumpling(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    -- Вычисляем очки за 'Dumpling' для каждого игрока\n    RETURN QUERY\n    WITH dumpling_count AS (\n        SELECT\n            tc.playerid,\n            COUNT(*) AS cnt\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Dumpling'\n        GROUP BY tc.playerid\n    )\n    SELECT\n        d.playerid,\n        CASE d.cnt\n          WHEN 1 THEN 1\n          WHEN 2 THEN 3\n          WHEN 3 THEN 6\n          WHEN 4 THEN 10\n          WHEN 5 THEN 15\n          ELSE \n            CASE WHEN d.cnt >= 5 THEN 15 ELSE 0 END\n        END AS points\n    FROM dumpling_count d;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_maki_rolls",
    "description": "Вычисляет очки за карты категории 'Maki Roll' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_maki_rolls(1);",
    "exampleReturns": "playerid: 1, points: 6",
    "code": "CREATE OR REPLACE FUNCTION compute_maki_rolls(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    -- Вычисляем очки за 'Maki Roll' для каждого игрока\n    RETURN QUERY\n    WITH maki_totals AS (\n        SELECT \n            tc.playerid AS playerid,\n            COALESCE(SUM(c.points), 0) AS total_maki\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Maki Roll'\n        GROUP BY tc.playerid\n    ),\n    ranked AS (\n        SELECT\n            maki_totals.playerid AS playerid,\n            maki_totals.total_maki AS total_maki,\n            DENSE_RANK() OVER (ORDER BY maki_totals.total_maki DESC) AS rnk\n        FROM maki_totals\n    ),\n    first_count AS (\n        SELECT COUNT(*) AS cnt\n        FROM ranked\n        WHERE ranked.rnk = 1\n    )\n    SELECT\n        ranked.playerid AS playerid,\n        CASE\n            WHEN ranked.rnk = 1 THEN 6\n            WHEN ranked.rnk = 2 \n                 AND (SELECT first_count.cnt FROM first_count) = 1\n                 THEN 3\n            ELSE 0\n        END AS points\n    FROM ranked;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_nigiri",
    "description": "Вычисляет базовые очки за карты категории 'Nigiri' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_nigiri(1);",
    "exampleReturns": "playerid: 1, points: 3",
    "code": "CREATE OR REPLACE FUNCTION compute_nigiri(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    -- Вычисляем базовые очки за 'Nigiri' для каждого игрока\n    RETURN QUERY\n    WITH nigiri_count AS (\n        SELECT \n            tc.playerid AS playerid,\n            SUM(c.points)::int AS total_nigiri\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Nigiri'\n        GROUP BY tc.playerid\n    )\n    SELECT \n        nigiri_count.playerid AS playerid,\n        nigiri_count.total_nigiri AS points\n    FROM nigiri_count;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_pudding",
    "description": "Вычисляет очки за карты категории 'Pudding' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_pudding(1);",
    "exampleReturns": "playerid: 1, points: 6",
    "code": "CREATE OR REPLACE FUNCTION compute_pudding(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    /*\n      Считаем количество карт 'Pudding' у каждого игрока на столе,\n      затем сравниваем с максимальным и минимальным количеством.\n      - Игроки с максимальным количеством (и max_cnt > 0) получают +6\n      - Игроки с минимальным количеством (и min_cnt > 0) получают -6\n      Если max_cnt = min_cnt (например, у всех по 2 или 0 пудингов),\n      они получают оба значения, что дает 0 в сумме (ничья).\n    */\n    RETURN QUERY\n    WITH pudding_count AS (\n        SELECT\n            tc.playerid,\n            COUNT(*) AS cnt\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Pudding'\n        GROUP BY tc.playerid\n    ),\n    stats AS (\n        SELECT \n            pc.playerid,\n            pc.cnt,\n            MAX(pc.cnt) OVER () AS max_cnt,\n            MIN(pc.cnt) OVER () AS min_cnt\n        FROM pudding_count pc\n    )\n    SELECT\n        s.playerid,\n        CASE\n            WHEN s.cnt = s.max_cnt AND s.max_cnt > 0 THEN 6\n            WHEN s.cnt = s.min_cnt AND s.min_cnt > 0 THEN -6\n            ELSE 0\n        END AS points\n    FROM stats s;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_sashimi",
    "description": "Вычисляет очки за карты категории 'Sashimi' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_sashimi(1);",
    "exampleReturns": "playerid: 1, points: 10",
    "code": "CREATE OR REPLACE FUNCTION compute_sashimi(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    -- Вычисляем очки за 'Sashimi' для каждого игрока\n    RETURN QUERY\n    WITH sashimi_count AS (\n        SELECT \n            tc.playerid AS playerid,\n            COUNT(*) AS cnt\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Sashimi'\n        GROUP BY tc.playerid\n    )\n    SELECT\n        sashimi_count.playerid AS playerid,\n        10 * ((sashimi_count.cnt)::int / 3) AS points -- Приведение COUNT к int\n    FROM sashimi_count;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_tempura",
    "description": "Вычисляет очки за карты категории 'Tempura' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_tempura(1);",
    "exampleReturns": "playerid: 1, points: 5",
    "code": "CREATE OR REPLACE FUNCTION compute_tempura(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    -- Вычисляем очки за 'Tempura' для каждого игрока\n    RETURN QUERY\n    WITH tempura_count AS (\n        SELECT \n            tc.playerid AS playerid,\n            COUNT(*) AS cnt\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Tempura'\n        GROUP BY tc.playerid\n    )\n    SELECT\n        t.playerid,\n        5 * (t.cnt::int / 2) AS points -- Приведение COUNT к int\n    FROM tempura_count t;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "compute_wasabi",
    "description": "Вычисляет дополнительные очки за карты 'Nigiri' на 'Wasabi' для каждого игрока в сессии.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "TABLE(playerid INT, points INT)",
    "usage": "SELECT * FROM compute_wasabi(1);",
    "exampleReturns": "playerid: 1, points: 6",
    "code": "CREATE OR REPLACE FUNCTION compute_wasabi(session_id INT)\nRETURNS TABLE(playerid INT, points INT) AS\n$$\nBEGIN\n    -- Вычисляем дополнительные очки за 'Nigiri' на 'Wasabi'\n    RETURN QUERY\n    WITH nigiri_on_wasabi AS (\n        SELECT \n            tc.playerid AS playerid,\n            c.points AS nigiri_base\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        LEFT JOIN TableCards wt ON wt.tablecardid = tc.under_tablecardid\n        LEFT JOIN SessionCards ws ON wt.sessioncardid = ws.sessioncardid\n        LEFT JOIN Cards w ON ws.cardid = w.cardid\n        WHERE sc.sessionid = session_id\n          AND c.category = 'Nigiri'\n          AND w.category = 'Wasabi'\n    )\n    SELECT\n        nigiri_on_wasabi.playerid AS playerid,\n        SUM(nigiri_on_wasabi.nigiri_base * 2)::int AS points\n    FROM nigiri_on_wasabi\n    GROUP BY nigiri_on_wasabi.playerid;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "create_session",
    "description": "Создает новую игровую сессию, сохраняя информацию о создателе, и автоматически присоединяет создателя к сессии.",
    "parameters": [
      {
        "name": "token",
        "type": "UUID",
        "description": "Токен сессии пользователя, создающего сессию."
      },
      {
        "name": "session_name",
        "type": "TEXT",
        "description": "Название игровой сессии."
      },
      {
        "name": "move_duration",
        "type": "INT",
        "description": "Длительность хода в секундах."
      },
      {
        "name": "player_count",
        "type": "INT",
        "description": "Максимальное количество игроков в сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT create_session('550e8400-e29b-41d4-a716-446655440000', 'Новая игра', 30, 4);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Сессия создана и присоединение выполнено успешно!\", \"session_id\": 1, \"join_result\": { \"success\": true, \"result_message\": \"Игрок успешно присоединился к сессии!\", \"session_id\": 1, \"player_id\": 1, \"game_started\": false } }",
    "code": "CREATE OR REPLACE FUNCTION create_session(\n    token UUID,\n    session_name TEXT,\n    move_duration INT,\n    player_count INT\n) RETURNS JSON AS $$\nDECLARE\n    session_id INT;\n    join_result JSON;\n    creator_user_id INT;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(token) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем user_id из токена, явно указывая параметр функции\n    SELECT st.user_id INTO creator_user_id\n    FROM session_tokens st\n    WHERE st.token = create_session.token\n    LIMIT 1;\n\n    -- Создаем новую сессию с указанием создателя\n    INSERT INTO GameSessions (\n        sessionname,\n        moveduration,\n        roundnumber,\n        sessiondate,\n        max_player_count,\n        current_player_count,\n        status,\n        created_by\n    )\n    VALUES (\n        session_name,\n        move_duration,\n        0,\n        NOW(),\n        player_count,\n        0,\n        'pending',\n        creator_user_id\n    )\n    RETURNING sessionid INTO session_id;\n\n    -- Присоединяем создателя к сессии\n    join_result := join_session(token, session_id);\n\n    -- Возвращаем успешный результат\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Сессия создана и присоединение выполнено успешно!',\n        'session_id', session_id,\n        'join_result', join_result\n    );\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;"
  },
  {
    "name": "deal_cards",
    "description": "Раздает карты игрокам в сессии в круговом порядке.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      },
      {
        "name": "cards_per_player",
        "type": "INT",
        "description": "Количество карт для каждого игрока."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT deal_cards(1, 8);",
    "exampleReturns": "void",
    "code": "CREATE OR REPLACE FUNCTION deal_cards(session_id INT, cards_per_player INT) RETURNS VOID AS $$\nDECLARE\n    player_ids INT[];            -- Массив ID игроков в сессии\n    undealt_cards INT[];         -- Массив неразданных sessioncardid\n    num_players INT;\n    total_cards_to_deal INT;\n    i INT;\n    player_index INT := 1;\n    assigned_cards INT[] := '{}'; -- Массив для отслеживания разданных карт\nBEGIN\n    -- 1. Получаем все ID игроков для этой сессии\n    SELECT ARRAY_AGG(playerid ORDER BY playerid) INTO player_ids\n    FROM Players\n    WHERE sessionid = session_id;\n\n    -- 2. Определяем, сколько всего карт нужно раздать\n    num_players := CARDINALITY(player_ids);\n    total_cards_to_deal := num_players * cards_per_player;\n    RAISE NOTICE 'Всего карт для раздачи: %', total_cards_to_deal;\n\n    -- 3. Выбираем ровно столько неразданных карт через подзапрос\n    SELECT ARRAY_AGG(sub.sessioncardid)\n    INTO undealt_cards\n    FROM (\n        SELECT sessioncardid\n        FROM SessionCards\n        WHERE sessionid = session_id\n          AND dealt = FALSE\n        ORDER BY RANDOM()\n        LIMIT total_cards_to_deal\n    ) AS sub;\n\n    RAISE NOTICE 'Выбраны неразданные карты: %', undealt_cards;\n\n    -- 4. Проверяем, достаточно ли карт\n    IF undealt_cards IS NULL OR CARDINALITY(undealt_cards) < total_cards_to_deal THEN\n        RAISE EXCEPTION 'Недостаточно неразданных карт для сессии: %', session_id;\n    END IF;\n\n    -- 5. Распределяем карты игрокам по кругу\n    FOR i IN 1..CARDINALITY(undealt_cards) LOOP\n        INSERT INTO PlayerCards (playerid, sessioncardid)\n        VALUES (player_ids[player_index], undealt_cards[i]);\n\n        assigned_cards := ARRAY_APPEND(assigned_cards, undealt_cards[i]);\n\n        RAISE NOTICE 'Карта % назначена игроку %', undealt_cards[i], player_ids[player_index];\n\n        -- Переходим к следующему игроку (по кругу)\n        player_index := (player_index % num_players) + 1;\n    END LOOP;\n\n    -- 6. Помечаем только разданные карты как выданные\n    UPDATE SessionCards\n    SET dealt = TRUE\n    WHERE sessioncardid = ANY (assigned_cards);\n\n    RAISE NOTICE 'Карты помечены как разданные: %', assigned_cards;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "delete_session",
    "description": "Удаляет игровую сессию, если пользователь является её создателем.",
    "parameters": [
      {
        "name": "token",
        "type": "UUID",
        "description": "Токен сессии пользователя, запрашивающего удаление."
      },
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор сессии для удаления."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT delete_session('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Сессия успешно удалена!\", \"session_id\": 1 }",
    "code": "CREATE OR REPLACE FUNCTION delete_session(token UUID, session_id INT) RETURNS JSON AS $$\nDECLARE\n    is_token_valid BOOLEAN;\n    session_exists BOOLEAN;\n    requesting_user_id INT;\n    session_creator_id INT;\nBEGIN\n    -- Проверяем валидность токена\n    is_token_valid := validate_token(token);\n\n    -- Если токен недействителен, возвращаем ошибку\n    IF NOT is_token_valid THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем user_id из токена, явно указывая параметр функции\n    SELECT st.user_id INTO requesting_user_id\n    FROM session_tokens st\n    WHERE st.token = delete_session.token\n    LIMIT 1;\n\n    -- Проверяем, существует ли сессия и получаем ID создателя\n    SELECT created_by INTO session_creator_id\n    FROM GameSessions\n    WHERE sessionid = session_id;\n\n    -- Если сессия не существует, возвращаем ошибку\n    IF session_creator_id IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Сессия не найдена'\n        );\n    END IF;\n\n    -- Проверяем, является ли пользователь создателем сессии\n    IF requesting_user_id != session_creator_id THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Только создатель сессии может её удалить'\n        );\n    END IF;\n\n    -- Удаляем сессию\n    DELETE FROM GameSessions WHERE sessionid = session_id;\n\n    -- Возвращаем успешный результат\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Сессия успешно удалена!',\n        'session_id', session_id\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "final_scoring_pudding",
    "description": "Выполняет финальное подсчитывание очков за карты 'Pudding' и обновляет таблицу очков игроков.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT final_scoring_pudding(1);",
    "exampleReturns": "[{ \"playerid\": 1, \"username\": \"user1\", \"score\": 6 }]",
    "code": "CREATE OR REPLACE FUNCTION final_scoring_pudding(session_id INT) RETURNS JSON AS\n$$\nDECLARE\n    rec RECORD;\n    final_result JSON;\nBEGIN\n    -- Обновляем очки за 'Pudding' для каждого игрока\n    FOR rec IN SELECT * FROM compute_pudding(session_id)\n    LOOP\n        INSERT INTO playerscores(playerid, score)\n        VALUES (rec.playerid, rec.points)\n        ON CONFLICT (playerid) \n        DO UPDATE SET score = playerscores.score + EXCLUDED.score;\n    END LOOP;\n\n    -- Возвращаем массив JSON с игроками и очками, отсортированный по убыванию очков\n    WITH final_scores AS (\n        SELECT ps.playerid, ps.score, u.username\n        FROM playerscores ps\n        JOIN players p ON p.playerid = ps.playerid\n        JOIN users u ON p.userid = u.userid\n        WHERE p.sessionid = session_id\n    )\n    SELECT json_agg(player_info) INTO final_result\n    FROM (\n      SELECT json_build_object(\n          'playerid', final_scores.playerid,\n          'username', final_scores.username,\n          'score', final_scores.score\n      ) AS player_info\n      FROM final_scores\n      ORDER BY final_scores.score DESC\n    ) sub;\n\n    -- Уведомляем клиентов о подсчете очков за 'Pudding'\n    PERFORM pg_notify(\n        'game_events',\n        json_build_object(\n            'session_id', session_id,\n            'event', 'pudding_scoring',\n            'results', final_result\n        )::text\n    );\n\n    RETURN final_result;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_player_cards",
    "description": "Получает карты в руке игрока для указанной сессии.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии игрока."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_player_cards('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Карты игрока успешно получены!\", \"cards\": [{ \"playercard_sessioncardid\": 1, \"card_id\": 1, \"card_type\": \"Nigiri\", \"card_description\": \"Salmon Nigiri\", \"points\": 2, \"dealt\": true }] }",
    "code": "CREATE OR REPLACE FUNCTION get_player_cards(_token UUID, _session_id INT)\nRETURNS JSON AS $$\nDECLARE\n    validated_user_id INT;\n    current_player_id INT;\n    player_cards JSON;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем ID пользователя из токена\n    SELECT st.user_id INTO validated_user_id\n    FROM session_tokens st\n    WHERE st.token = _token;\n\n    -- Получаем ID игрока в указанной сессии\n    SELECT p.playerid INTO current_player_id\n    FROM players p\n    WHERE p.userid = validated_user_id\n      AND p.sessionid = _session_id;\n\n    IF current_player_id IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Пользователь не является частью этой сессии'\n        );\n    END IF;\n\n    -- Получаем карты игрока, соединяя таблицы PlayerCards, SessionCards и Cards\n    SELECT json_agg(\n             json_build_object(\n               'playercard_sessioncardid', pc.sessioncardid,\n               'card_id', c.cardid,\n               'card_type', c.cardtype,\n               'card_description', c.carddescription,\n               'points', c.points,\n               'dealt', sc.dealt\n             )\n           )\n    INTO player_cards\n    FROM playercards pc\n    JOIN sessioncards sc ON pc.sessioncardid = sc.sessioncardid\n    JOIN cards c ON sc.cardid = c.cardid\n    WHERE pc.playerid = current_player_id;\n\n    RETURN json_build_object(\n         'success', TRUE,\n         'result_message', 'Карты игрока успешно получены!',\n         'cards', COALESCE(player_cards, '[]'::JSON)\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_player_scores",
    "description": "Получает очки игроков в указанной сессии.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_player_scores('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"sessionid\": 1, \"players\": [{ \"username\": \"user1\", \"score\": 15 }] }",
    "code": "CREATE OR REPLACE FUNCTION get_player_scores(_token UUID, _session_id INT)\nRETURNS JSON AS $$\nDECLARE\n    is_valid BOOLEAN;\n    result JSON;\nBEGIN\n    -- Проверяем валидность токена\n    is_valid := validate_token(_token);\n    IF NOT is_valid THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем данные об очках игроков\n    SELECT json_build_object(\n        'sessionid', _session_id,\n        'players', COALESCE((\n            SELECT json_agg(player_data)\n            FROM (\n                SELECT u.username, ps.score\n                FROM players p\n                JOIN playerscores ps ON p.playerid = ps.playerid\n                JOIN users u ON p.userid = u.userid\n                WHERE p.sessionid = _session_id\n                ORDER BY ps.score DESC\n            ) AS player_data\n        ), '[]'::json)\n    )\n    INTO result\n    FROM GameSessions\n    WHERE sessionid = _session_id;\n\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_player_table_cards",
    "description": "Получает карты игрока на столе в указанной сессии.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии игрока."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_player_table_cards('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Карты игрока на столе успешно получены!\", \"table_cards\": [{ \"tablecard_id\": 1, \"sessioncard_id\": 1, \"card_id\": 1, \"card_type\": \"Nigiri\", \"card_description\": \"Salmon Nigiri\", \"points\": 2, \"under_table_card\": null }] }",
    "code": "CREATE OR REPLACE FUNCTION get_player_table_cards(_token UUID, _session_id INT)\nRETURNS JSON AS $$\nDECLARE\n    validated_user_id INT;\n    current_player_id INT;\n    table_cards JSON;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем ID пользователя из токена\n    SELECT st.user_id INTO validated_user_id\n    FROM session_tokens st\n    WHERE st.token = _token;\n\n    -- Получаем ID игрока в сессии\n    SELECT p.playerid INTO current_player_id\n    FROM players p\n    WHERE p.userid = validated_user_id\n      AND p.sessionid = _session_id;\n\n    IF current_player_id IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Пользователь не является частью этой сессии'\n        );\n    END IF;\n\n    -- Получаем верхние карты на столе (не являющиеся подкартами)\n    SELECT json_agg(\n               json_build_object(\n                   'tablecard_id', tc.tablecardid,\n                   'sessioncard_id', tc.sessioncardid,\n                   'card_id', c.cardid,\n                   'card_type', c.cardtype,\n                   'card_description', c.carddescription,\n                   'points', c.points,\n                   'under_table_card', get_under_table_card(tc.under_tablecardid)\n               )\n           )\n    INTO table_cards\n    FROM tablecards tc\n    JOIN sessioncards sc ON tc.sessioncardid = sc.sessioncardid\n    JOIN cards c ON sc.cardid = c.cardid\n    WHERE tc.playerid = current_player_id\n      AND sc.sessionid = _session_id\n      AND NOT EXISTS (\n             SELECT 1 FROM tablecards t2 WHERE t2.under_tablecardid = tc.tablecardid\n      );\n\n    RETURN json_build_object(\n         'success', TRUE,\n         'result_message', 'Карты игрока на столе успешно получены!',\n         'table_cards', COALESCE(table_cards, '[]'::JSON)\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_player_table_cards_by_playerid",
    "description": "Получает карты на столе для указанного игрока по его ID в сессии.",
    "parameters": [
      {
        "name": "_playerid",
        "type": "INT",
        "description": "Идентификатор игрока."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_player_table_cards_by_playerid(1, 1);",
    "exampleReturns": "[{ \"tablecard_id\": 1, \"sessioncard_id\": 1, \"card_id\": 1, \"card_type\": \"Nigiri\", \"card_description\": \"Salmon Nigiri\", \"points\": 2, \"under_table_card\": null }]",
    "code": "CREATE OR REPLACE FUNCTION get_player_table_cards_by_playerid(_playerid INT, _session_id INT)\nRETURNS JSON AS $$\nDECLARE\n    table_cards JSON;\nBEGIN\n    -- Получаем верхние карты на столе (не являющиеся подкартами)\n    SELECT json_agg(\n               json_build_object(\n                   'tablecard_id', tc.tablecardid,\n                   'sessioncard_id', tc.sessioncardid,\n                   'card_id', c.cardid,\n                   'card_type', c.cardtype,\n                   'card_description', c.carddescription,\n                   'points', c.points,\n                   'under_table_card', get_under_table_card(tc.under_tablecardid)\n               )\n           ) INTO table_cards\n    FROM tablecards tc\n    JOIN sessioncards sc ON tc.sessioncardid = sc.sessioncardid\n    JOIN cards c ON sc.cardid = c.cardid\n    WHERE tc.playerid = _playerid\n      AND sc.sessionid = _session_id\n      AND NOT EXISTS (\n            SELECT 1 \n            FROM tablecards t2 \n            WHERE t2.under_tablecardid = tc.tablecardid\n      );\n      \n    RETURN COALESCE(table_cards, '[]'::json);\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_session",
    "description": "Получает информацию об одной игровой сессии по её идентификатору.",
    "parameters": [
      {
        "name": "token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      },
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_session('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Сессия успешно получена!\", \"session\": { \"session_id\": 1, \"session_name\": \"Новая игра\", \"move_duration\": 30, \"round_number\": 0, \"session_date\": \"2025-03-03T12:00:00\", \"current_player_count\": 1, \"max_player_count\": 4, \"status\": \"pending\", \"scheduled_time\": null } }",
    "code": "CREATE OR REPLACE FUNCTION get_session(token UUID, session_id INT) RETURNS JSON AS $$\nDECLARE\n    is_token_valid BOOLEAN;\n    session JSON;\nBEGIN\n    -- Проверяем валидность токена\n    is_token_valid := validate_token(token);\n    IF NOT is_token_valid THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем информацию о сессии\n    SELECT json_build_object(\n        'session_id', sessionid,\n        'session_name', sessionname,\n        'move_duration', moveduration,\n        'round_number', roundnumber,\n        'session_date', sessiondate,\n        'current_player_count', current_player_count,\n        'max_player_count', max_player_count,\n        'status', status,\n        'scheduled_time', scheduled_time  -- Должно включать информацию о часовом поясе\n    ) INTO session\n    FROM GameSessions\n    WHERE sessionid = session_id;\n\n    -- Если сессия не найдена, возвращаем ошибку\n    IF session IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Сессия не найдена по указанному session_id'\n        );\n    END IF;\n\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Сессия успешно получена!',\n        'session', session\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_session_players",
    "description": "Получает список игроков, присоединившихся к сессии, и информацию о готовности к началу.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_session_players('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Игроки сессии успешно получены!\", \"players\": [{ \"player_id\": 1, \"username\": \"user1\" }], \"current_player_count\": 1, \"max_player_count\": 4, \"ready_to_start\": false }",
    "code": "CREATE OR REPLACE FUNCTION get_session_players(_token UUID, _session_id INT)\nRETURNS JSON AS $$\nDECLARE\n    is_token_valid BOOLEAN;\n    session_player_count INT;\n    joined_players JSON;\n    max_players INT;\nBEGIN\n    -- Проверяем валидность токена\n    is_token_valid := validate_token(_token);\n\n    IF NOT is_token_valid THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем максимальное количество игроков для сессии\n    SELECT max_player_count INTO max_players\n    FROM gamesessions\n    WHERE sessionid = _session_id;\n\n    -- Считаем количество присоединившихся игроков\n    SELECT COUNT(*) INTO session_player_count\n    FROM players\n    WHERE sessionid = _session_id;\n\n    -- Получаем список присоединившихся игроков\n    SELECT json_agg(\n        json_build_object(\n            'player_id', p.playerid,\n            'username', u.username\n        )\n    ) INTO joined_players\n    FROM players p\n    JOIN users u ON p.userid = u.userid\n    WHERE p.sessionid = _session_id;\n\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Игроки сессии успешно получены!',\n        'players', COALESCE(joined_players, '[]'::json),\n        'current_player_count', session_player_count,\n        'max_player_count', max_players,\n        'ready_to_start', session_player_count = max_players\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_sessions",
    "description": "Получает список всех сессий со статусом 'pending', отсортированных по дате убывания.",
    "parameters": [
      {
        "name": "token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_sessions('550e8400-e29b-41d4-a716-446655440000');",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Сессии успешно получены!\", \"sessions\": [{ \"session_id\": 1, \"session_name\": \"Новая игра\", \"move_duration\": 30, \"round_number\": 0, \"session_date\": \"2025-03-03T12:00:00\", \"current_player_count\": 1, \"max_player_count\": 4 }] }",
    "code": "CREATE OR REPLACE FUNCTION get_sessions(token UUID) RETURNS JSON AS $$\nDECLARE\n    is_token_valid BOOLEAN;\n    sessions JSON;\nBEGIN\n    -- Проверяем валидность токена\n    is_token_valid := validate_token(token);\n\n    IF NOT is_token_valid THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем только сессии со статусом 'pending', отсортированные по дате убывания\n    SELECT json_agg(\n            json_build_object(\n                'session_id', sessionid,\n                'session_name', sessionname,\n                'move_duration', moveduration,\n                'round_number', roundnumber,\n                'session_date', sessiondate,\n                'current_player_count', current_player_count,\n                'max_player_count', max_player_count\n            )\n        ) INTO sessions\n    FROM (\n        SELECT \n            sessionid, \n            sessionname, \n            moveduration, \n            roundnumber, \n            sessiondate, \n            current_player_count, \n            max_player_count\n        FROM GameSessions\n        WHERE status = 'pending'\n        ORDER BY sessiondate DESC  -- Сортировка по дате убывания\n    ) AS ordered_sessions;\n\n    IF sessions IS NULL THEN\n        RETURN json_build_object(\n            'success', TRUE,\n            'result_message', 'Сессии не найдены',\n            'sessions', json_build_array()\n        );\n    END IF;\n\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Сессии успешно получены!',\n        'sessions', sessions\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_table_cards",
    "description": "Получает карты на столе для всех игроков в сессии, начиная с текущего игрока.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_table_cards('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Карты на столе сессии успешно получены!\", \"players\": [{ \"player_id\": 1, \"username\": \"user1\", \"cards\": [{ \"tablecard_id\": 1, \"sessioncard_id\": 1, \"card_id\": 1, \"card_type\": \"Nigiri\", \"card_description\": \"Salmon Nigiri\", \"points\": 2, \"under_table_card\": null }] }] }",
    "code": "CREATE OR REPLACE FUNCTION get_table_cards(_token UUID, _session_id INT)\nRETURNS JSON AS $$\nDECLARE\n    players_cards JSON;\n    current_player_id INT;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n         RETURN json_build_object(\n           'success', FALSE,\n           'result_message', 'Ошибка: Недействительный или просроченный токен'\n         );\n    END IF;\n\n    -- Определяем ID текущего игрока по токену и сессии\n    SELECT p.playerid INTO current_player_id\n    FROM players p\n    JOIN session_tokens st ON p.userid = st.user_id\n    WHERE st.token = _token\n      AND p.sessionid = _session_id;\n\n    IF current_player_id IS NULL THEN\n         RETURN json_build_object(\n           'success', FALSE,\n           'result_message', 'Ошибка: Пользователь не является частью этой сессии'\n         );\n    END IF;\n\n    /*\n      Используем рекурсивный CTE для упорядочивания игроков по круговому списку.\n      Цепочка начинается с текущего игрока и следует за nextplayerid.\n    */\n    WITH RECURSIVE ordered_players AS (\n      -- Базовый случай: текущий игрок\n      SELECT \n         p.playerid, \n         u.username, \n         p.nextplayerid, \n         1 AS lvl\n      FROM players p\n      JOIN users u ON p.userid = u.userid\n      WHERE p.sessionid = _session_id\n        AND p.playerid = current_player_id\n      UNION ALL\n      -- Рекурсивный случай: следующий игрок в цепочке\n      SELECT \n         p.playerid, \n         u.username, \n         p.nextplayerid,\n         op.lvl + 1 AS lvl\n      FROM players p\n      JOIN users u ON p.userid = u.userid\n      JOIN ordered_players op ON p.playerid = op.nextplayerid\n      WHERE p.sessionid = _session_id\n        AND p.playerid <> current_player_id\n    )\n    SELECT json_agg(player_info) INTO players_cards\n    FROM (\n      SELECT json_build_object(\n         'player_id', op.playerid,\n         'username', op.username,\n         'cards', get_player_table_cards_by_playerid(op.playerid, _session_id)\n      ) AS player_info\n      FROM ordered_players op\n      ORDER BY op.lvl\n    ) sub;\n\n    RETURN json_build_object(\n         'success', TRUE,\n         'result_message', 'Карты на столе сессии успешно получены!',\n         'players', COALESCE(players_cards, '[]'::json)\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_under_table_card",
    "description": "Получает информацию о карте под указанной картой на столе (рекурсивно).",
    "parameters": [
      {
        "name": "_under_tablecardid",
        "type": "INT",
        "description": "Идентификатор карты на столе, для которой нужно найти подкарту."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_under_table_card(1);",
    "exampleReturns": "{ \"tablecard_id\": 2, \"sessioncard_id\": 2, \"card_id\": 2, \"card_type\": \"Wasabi\", \"card_description\": \"Wasabi\", \"points\": 0, \"under_table_card\": null }",
    "code": "CREATE OR REPLACE FUNCTION get_under_table_card(_under_tablecardid INT)\nRETURNS JSON AS $$\nDECLARE\n    under_card JSON;\nBEGIN\n    -- Если ID подкарты отсутствует, возвращаем NULL\n    IF _under_tablecardid IS NULL THEN\n        RETURN NULL;\n    END IF;\n    \n    -- Получаем информацию о подкарте\n    SELECT json_build_object(\n               'tablecard_id', tc.tablecardid,\n               'sessioncard_id', tc.sessioncardid,\n               'card_id', c.cardid,\n               'card_type', c.cardtype,\n               'card_description', c.carddescription,\n               'points', c.points,\n               'under_table_card', get_under_table_card(tc.under_tablecardid)\n           )\n    INTO under_card\n    FROM tablecards tc\n    JOIN sessioncards sc ON tc.sessioncardid = sc.sessioncardid\n    JOIN cards c ON sc.cardid = c.cardid\n    WHERE tc.tablecardid = _under_tablecardid;\n    \n    RETURN under_card;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_user",
    "description": "Получает информацию о пользователе по его токену сессии.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_user('550e8400-e29b-41d4-a716-446655440000');",
    "exampleReturns": "{ \"success\": true, \"message\": \"Пользователь успешно получен!\", \"user\": { \"user_id\": 1, \"username\": \"user1\" } }",
    "code": "CREATE OR REPLACE FUNCTION get_user(_token UUID)\nRETURNS JSON AS $$\nDECLARE\n    _user_id INT;\n    _user JSON;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n      RETURN json_build_object(\n          'success', FALSE,\n          'message', 'Недействительный или просроченный токен'\n      );\n    END IF;\n\n    -- Получаем user_id из токена\n    SELECT st.user_id\n      INTO _user_id\n    FROM session_tokens st\n    WHERE st.token = _token\n    LIMIT 1;\n\n    -- Если пользователь не найден, возвращаем ошибку\n    IF _user_id IS NULL THEN\n      RETURN json_build_object(\n          'success', FALSE,\n          'message', 'Пользователь не найден'\n      );\n    END IF;\n\n    -- Получаем данные пользователя\n    SELECT json_build_object(\n         'user_id', u.userid,\n         'username', u.username\n    )\n      INTO _user\n    FROM users u\n    WHERE u.userid = _user_id;\n\n    RETURN json_build_object(\n       'success', TRUE,\n       'message', 'Пользователь успешно получен!',\n       'user', _user\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "get_user_sessions",
    "description": "Получает список сессий, в которых участвует пользователь, отсортированных по дате убывания.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT get_user_sessions('550e8400-e29b-41d4-a716-446655440000');",
    "exampleReturns": "{ \"success\": true, \"message\": \"Сессии успешно получены!\", \"user_id\": 1, \"sessions\": [{ \"sessionid\": 1, \"sessionname\": \"Новая игра\", \"moveduration\": 30, \"max_player_count\": 4, \"status\": \"pending\", \"sessiondate\": \"2025-03-03T12:00:00\" }] }",
    "code": "CREATE OR REPLACE FUNCTION get_user_sessions(_token UUID)\nRETURNS JSON AS $$\nDECLARE\n    _user_id INT;\n    _sessions JSON;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n      RETURN json_build_object(\n          'success', FALSE,\n          'message', 'Недействительный или просроченный токен'\n      );\n    END IF;\n\n    -- Получаем user_id из токена\n    SELECT st.user_id \n      INTO _user_id\n    FROM session_tokens st\n    WHERE st.token = _token\n    LIMIT 1;\n\n    -- Если пользователь не найден, возвращаем ошибку\n    IF _user_id IS NULL THEN\n      RETURN json_build_object(\n          'success', FALSE,\n          'message', 'Пользователь не найден'\n      );\n    END IF;\n\n    -- Получаем сессии, в которых участвует пользователь, отсортированные по дате убывания\n    SELECT json_agg(s)\n      INTO _sessions\n    FROM (\n        SELECT \n            gs.sessionid,\n            gs.sessionname,\n            gs.moveduration,\n            gs.max_player_count,\n            gs.status,\n            gs.sessiondate\n        FROM gamesessions gs\n        JOIN players p ON gs.sessionid = p.sessionid\n        WHERE p.userid = _user_id\n        ORDER BY gs.sessiondate DESC\n    ) s;\n\n    RETURN json_build_object(\n       'success', TRUE,\n       'message', 'Сессии успешно получены!',\n       'user_id', _user_id,\n       'sessions', COALESCE(_sessions, '[]'::json)\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "increment_round",
    "description": "Увеличивает номер раунда в указанной сессии на 1.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT increment_round(1);",
    "exampleReturns": "void",
    "code": "CREATE OR REPLACE FUNCTION increment_round(session_id INT) RETURNS VOID AS $$\nBEGIN\n    -- Увеличиваем номер раунда в сессии\n    UPDATE GameSessions\n    SET roundnumber = roundnumber + 1\n    WHERE sessionid = session_id;\nEND;\n$$ LANGUAGE plpgsql;"
  },

  {
    "name": "initialize_session_cards",
    "description": "Инициализирует карты для указанной сессии, добавляя все карты в таблицу SessionCards.",
    "parameters": [
      {
        "name": "session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT initialize_session_cards(1);",
    "exampleReturns": "void",
    "code": "CREATE OR REPLACE FUNCTION initialize_session_cards(session_id INT) RETURNS VOID AS $$\nBEGIN\n    -- Добавляем все карты в таблицу SessionCards для данной сессии\n    INSERT INTO SessionCards (sessionid, cardid)\n    SELECT session_id, cardid\n    FROM Cards;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "is_player_belongs_session",
    "description": "Проверяет, является ли пользователь участником указанной сессии.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "BOOLEAN",
    "usage": "SELECT is_player_belongs_session('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "TRUE",
    "code": "CREATE OR REPLACE FUNCTION is_player_belongs_session(_token UUID, _session_id INT)\nRETURNS BOOLEAN AS $$\nBEGIN\n    -- Проверяем, есть ли запись о пользователе в сессии\n    RETURN EXISTS (\n        SELECT 1\n        FROM players p\n        JOIN session_tokens st ON p.userid = st.user_id\n        WHERE st.token = _token\n          AND p.sessionid = _session_id\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "join_session",
    "description": "Присоединяет игрока к указанной игровой сессии, если есть свободные места, и запускает игру, если сессия заполнена.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии пользователя, желающего присоединиться."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT join_session('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Игрок успешно присоединился к сессии!\", \"session_id\": 1, \"player_id\": 1, \"game_started\": false }",
    "code": "CREATE OR REPLACE FUNCTION join_session(_token UUID, _session_id INT) RETURNS JSON AS $$\nDECLARE\n    validated_user_id INT;\n    v_current_player_count INT;\n    max_player_count INT;\n    first_player_id INT;\n    last_player_id INT;\n    new_player_id INT;\n    join_response jsonb;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем ID пользователя из токена\n    SELECT st.user_id INTO validated_user_id\n    FROM session_tokens st\n    WHERE st.token = _token;\n\n    -- Считаем текущее количество игроков в сессии\n    SELECT COUNT(*) INTO v_current_player_count\n    FROM players\n    WHERE sessionid = _session_id;\n\n    -- Получаем максимальное количество игроков для сессии\n    SELECT gs.max_player_count INTO max_player_count\n    FROM gamesessions gs\n    WHERE gs.sessionid = _session_id;\n\n    -- Если сессия не найдена, возвращаем ошибку\n    IF max_player_count IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Сессия не найдена'\n        );\n    -- Если сессия заполнена, возвращаем ошибку\n    ELSIF v_current_player_count >= max_player_count THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Сессия заполнена'\n        );\n    END IF;\n\n    -- Находим первого игрока в сессии\n    SELECT p.playerid INTO first_player_id\n    FROM players p\n    WHERE p.sessionid = _session_id\n    ORDER BY p.playerid ASC\n    LIMIT 1;\n\n    -- Находим последнего игрока в сессии\n    SELECT p.playerid INTO last_player_id\n    FROM players p\n    WHERE p.sessionid = _session_id\n    ORDER BY p.playerid DESC\n    LIMIT 1;\n\n    -- Добавляем нового игрока в сессию\n    INSERT INTO players (userid, sessionid, nextplayerid)\n    VALUES (validated_user_id, _session_id, NULL)\n    RETURNING playerid INTO new_player_id;\n\n    -- Если это первый игрок, указываем его как следующего для себя\n    IF first_player_id IS NULL THEN\n        UPDATE players\n        SET nextplayerid = new_player_id\n        WHERE playerid = new_player_id;\n    ELSE\n        -- Обновляем круговую цепочку игроков\n        UPDATE players\n        SET nextplayerid = new_player_id\n        WHERE playerid = last_player_id;\n\n        UPDATE players\n        SET nextplayerid = first_player_id\n        WHERE playerid = new_player_id;\n    END IF;\n\n    -- Увеличиваем количество текущих игроков в сессии\n    UPDATE gamesessions\n    SET current_player_count = COALESCE(current_player_count, 0) + 1\n    WHERE sessionid = _session_id;\n\n    -- Формируем базовый ответ о присоединении\n    join_response := jsonb_build_object(\n        'success', TRUE,\n        'result_message', 'Игрок успешно присоединился к сессии!',\n        'session_id', _session_id,\n        'player_id', new_player_id\n    );\n\n    -- Если сессия заполнена после присоединения, запускаем игру\n    IF (v_current_player_count + 1) = max_player_count THEN\n        PERFORM start_game_session(_session_id); -- Запуск выполняется от имени владельца\n        join_response := join_response || jsonb_build_object('game_started', TRUE);\n    ELSE\n        join_response := join_response || jsonb_build_object('game_started', FALSE);\n    END IF;\n\n    RETURN join_response::json;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;"
  },
  {
    "name": "leave_session",
    "description": "Позволяет игроку покинуть игровую сессию.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии игрока."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT leave_session('550e8400-e29b-41d4-a716-446655440000', 1);",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Игрок успешно покинул сессию!\" }",
    "code": "CREATE OR REPLACE FUNCTION leave_session(_token UUID, _session_id INT) RETURNS JSON AS $$\nDECLARE\n    validated_user_id INT;\n    current_player_id INT;\nBEGIN\n    -- Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- Получаем ID пользователя из токена\n    SELECT st.user_id INTO validated_user_id\n    FROM session_tokens st\n    WHERE st.token = _token;\n\n    -- Получаем ID игрока в сессии\n    SELECT p.playerid INTO current_player_id\n    FROM players p\n    WHERE p.userid = validated_user_id\n      AND p.sessionid = _session_id;\n\n    IF current_player_id IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Пользователь не является частью этой сессии'\n        );\n    END IF;\n\n    -- Удаляем запись об игроке (покидаем сессию)\n    DELETE FROM players\n    WHERE playerid = current_player_id;\n\n    -- Уменьшаем количество текущих игроков в сессии\n    UPDATE gamesessions\n    SET current_player_count = current_player_count - 1\n    WHERE sessionid = _session_id;\n\n    RETURN json_build_object(\n         'success', TRUE,\n         'result_message', 'Игрок успешно покинул сессию!'\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "login_user",
    "description": "Выполняет вход пользователя, проверяя имя пользователя и пароль, и возвращает существующий или новый токен сессии.",
    "parameters": [
      {
        "name": "_username",
        "type": "TEXT",
        "description": "Имя пользователя."
      },
      {
        "name": "_password",
        "type": "TEXT",
        "description": "Пароль пользователя в открытом виде."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT login_user('user1', 'password123');",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Вход выполнен успешно!\", \"token\": \"550e8400-e29b-41d4-a716-446655440000\" }",
    "code": "CREATE OR REPLACE FUNCTION login_user(_username TEXT, _password TEXT) RETURNS JSON AS $$\nDECLARE\n    _user_id INT; \n    _user_token UUID;\n    _token_creation_time TIMESTAMP;\nBEGIN\n    -- Проверяем, совпадают ли имя пользователя и хеш пароля\n    SELECT u.userid INTO _user_id\n    FROM Users u\n    WHERE u.username = _username AND u.passwordhash = MD5(_password);\n\n    -- Если пользователь не найден, возвращаем ошибку\n    IF _user_id IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Неверное имя пользователя или пароль'\n        );\n    END IF;\n\n    -- Проверяем наличие активного токена\n    SELECT st.token, st.created_at INTO _user_token, _token_creation_time\n    FROM session_tokens st\n    WHERE st.user_id = _user_id\n    ORDER BY st.created_at DESC\n    LIMIT 1;\n\n    -- Если существует действительный токен\n    IF _user_token IS NOT NULL AND _token_creation_time > NOW() - INTERVAL '1 month' THEN\n        RETURN json_build_object(\n            'success', TRUE,\n            'result_message', 'Вход выполнен успешно!',\n            'token', _user_token::UUID\n        );\n    ELSE\n        -- Удаляем просроченные токены\n        DELETE FROM session_tokens\n        WHERE session_tokens.user_id = _user_id\n          AND session_tokens.created_at < NOW() - INTERVAL '1 month';\n\n        -- Генерируем новый токен\n        _user_token := gen_random_uuid();\n\n        -- Сохраняем новый токен\n        INSERT INTO session_tokens (user_id, token, created_at)\n        VALUES (_user_id, _user_token, NOW());\n\n        -- Возвращаем новый токен\n        RETURN json_build_object(\n            'success', TRUE,\n            'result_message', 'Вход выполнен успешно!',\n            'token', _user_token::UUID\n        );\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "pass_cards",
    "description": "Передает карты игроков следующему игроку в сессии.",
    "parameters": [
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT pass_cards(1);",
    "exampleReturns": "{ \"success\": true, \"message\": \"Все игроки передали свои карты следующему игроку\" }",
    "code": "CREATE OR REPLACE FUNCTION pass_cards(\n    _session_id INT\n) RETURNS JSON AS $$\nDECLARE\n    current_player_count INT;\nBEGIN\n    -- Проверяем, достаточно ли игроков в сессии\n    SELECT COUNT(*) INTO current_player_count\n    FROM Players\n    WHERE sessionid = _session_id;\n\n    IF current_player_count < 2 THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'message', 'Недостаточно игроков для передачи карт'\n        );\n    END IF;\n\n    -- Передаем карты каждому следующему игроку с помощью CTE\n    WITH pass_map AS (\n        SELECT p.playerid AS old_owner,\n               p.nextplayerid AS new_owner\n        FROM Players p\n        WHERE p.sessionid = _session_id\n    )\n    UPDATE PlayerCards pc\n    SET playerid = pass_map.new_owner\n    FROM pass_map\n    WHERE pc.playerid = pass_map.old_owner;\n\n    -- Возвращаем успех\n    RETURN json_build_object(\n        'success', TRUE,\n        'message', 'Все игроки передали свои карты следующему игроку'\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "place_card_on_table",
    "description": "Размещает карту из руки игрока на столе с учетом правил стека.",
    "parameters": [
      {
        "name": "_token",
        "type": "UUID",
        "description": "Токен сессии игрока."
      },
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      },
      {
        "name": "_sessioncard_id",
        "type": "INT",
        "description": "Идентификатор карты сессии, которую нужно разместить."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT place_card_on_table('550e8400-e29b-41d4-a716-446655440000', 1, 1);",
    "exampleReturns": "{ \"success\": true, \"message\": \"Карта успешно размещена на столе!\", \"player_id\": 1, \"sessioncard_id\": 1, \"under_table_card_id\": null }",
    "code": "CREATE OR REPLACE FUNCTION place_card_on_table(\n    _token UUID,\n    _session_id INT,\n    _sessioncard_id INT\n) RETURNS JSON AS $$\nDECLARE\n    validated_user_id INT;\n    current_player_id INT;\n    row_exists BOOLEAN;\n    card_type TEXT;\n    under_table_card_id INT DEFAULT NULL;\nBEGIN\n    -- 1. Проверяем валидность токена\n    IF NOT validate_token(_token) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'message', 'Ошибка: Недействительный или просроченный токен'\n        );\n    END IF;\n\n    -- 2. Определяем ID пользователя из токена\n    SELECT st.user_id INTO validated_user_id\n    FROM session_tokens st\n    WHERE st.token = _token;\n\n    -- 3. Находим ID игрока в указанной сессии\n    SELECT p.playerid INTO current_player_id\n    FROM Players p\n    WHERE p.userid = validated_user_id\n      AND p.sessionid = _session_id;\n\n    IF current_player_id IS NULL THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'message', 'Ошибка: Пользователь не является частью этой сессии'\n        );\n    END IF;\n\n    -- 4. Проверяем, есть ли карта в руке игрока\n    SELECT EXISTS (\n        SELECT 1\n        FROM PlayerCards pc\n        JOIN SessionCards sc ON pc.sessioncardid = sc.sessioncardid\n        WHERE pc.playerid = current_player_id\n          AND pc.sessioncardid = _sessioncard_id\n          AND sc.sessionid = _session_id\n    ) INTO row_exists;\n\n    IF NOT row_exists THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'message', 'Ошибка: Карты нет в руке игрока'\n        );\n    END IF;\n\n    -- 5. Получаем тип карты\n    SELECT c.cardtype INTO card_type\n    FROM SessionCards sc\n    JOIN Cards c ON sc.cardid = c.cardid\n    WHERE sc.sessioncardid = _sessioncard_id\n      AND sc.sessionid = _session_id;\n\n    -- 6. Определяем правила стека на основе типа карты\n    IF card_type = 'Wasabi' THEN\n        -- Для карт 'Wasabi' всегда размещаем без подкарты\n        under_table_card_id := NULL;\n    ELSIF card_type IN ('Egg Nigiri', 'Salmon Nigiri', 'Squid Nigiri') THEN\n        -- Сначала ищем существующую карту 'Nigiri' того же типа\n        SELECT tc.tablecardid INTO under_table_card_id\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE tc.playerid = current_player_id\n          AND sc.sessionid = _session_id\n          AND c.cardtype = card_type\n        ORDER BY tc.tablecardid DESC\n        LIMIT 1;\n        \n        IF under_table_card_id IS NULL THEN\n            -- Если 'Nigiri' того же типа нет, ищем свободную карту 'Wasabi'\n            SELECT tc.tablecardid INTO under_table_card_id\n            FROM TableCards tc\n            JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n            JOIN Cards c ON sc.cardid = c.cardid\n            WHERE tc.playerid = current_player_id\n              AND sc.sessionid = _session_id\n              AND c.cardtype = 'Wasabi'\n              AND NOT EXISTS (\n                 SELECT 1 \n                 FROM TableCards t2\n                 WHERE t2.under_tablecardid = tc.tablecardid\n              )\n            LIMIT 1;\n        END IF;\n    ELSE\n        -- Для других типов карт размещаем на последней карте того же типа\n        SELECT tc.tablecardid INTO under_table_card_id\n        FROM TableCards tc\n        JOIN SessionCards sc ON tc.sessioncardid = sc.sessioncardid\n        JOIN Cards c ON sc.cardid = c.cardid\n        WHERE tc.playerid = current_player_id\n          AND sc.sessionid = _session_id\n          AND c.cardtype = card_type\n        ORDER BY tc.tablecardid DESC\n        LIMIT 1;\n    END IF;\n\n    -- 7. Удаляем карту из руки игрока\n    DELETE FROM PlayerCards\n    WHERE playerid = current_player_id\n      AND sessioncardid = _sessioncard_id;\n\n    -- 8. Добавляем карту на стол с определенным under_table_card_id\n    INSERT INTO TableCards (playerid, sessioncardid, under_tablecardid)\n    VALUES (current_player_id, _sessioncard_id, under_table_card_id);\n\n    -- 9. Возвращаем успешный результат\n    RETURN json_build_object(\n        'success', TRUE,\n        'message', 'Карта успешно размещена на столе!',\n        'player_id', current_player_id,\n        'sessioncard_id', _sessioncard_id,\n        'under_table_card_id', under_table_card_id\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "process_move_timeout",
    "description": "Обрабатывает тайм-аут хода в сессии, автоматически отправляя карты непроигравших игроков, передавая карты и управляя раундами.",
    "parameters": [
      {
        "name": "_session_id",
        "type": "INT",
        "description": "Идентификатор игровой сессии."
      }
    ],
    "returns": "VOID",
    "usage": "SELECT process_move_timeout(1);",
    "exampleReturns": "VOID",
    "code": "CREATE OR REPLACE FUNCTION process_move_timeout(_session_id INT) RETURNS VOID AS $$\nDECLARE\n    move_duration INT;\nBEGIN\n    RAISE NOTICE 'process_move_timeout triggered for session %', _session_id;\n\n    -- Автоматически отправляем карты для игроков, которые не сыграли\n    PERFORM auto_submit_unplaced_cards(_session_id);\n\n    -- Если у игроков остались карты, планируем следующий тайм-аут\n    IF players_have_cards(_session_id) THEN\n        PERFORM pass_cards(_session_id);\n        SELECT moveduration INTO move_duration FROM gamesessions WHERE sessionid = _session_id;\n        PERFORM cron.schedule(\n             'session_' || _session_id || '_move_timeout',\n             move_duration::text || ' seconds',\n             'SELECT process_move_timeout(' || _session_id || ');'\n        );\n        -- Обновляем scheduled_time для следующего тайм-аута\n        UPDATE gamesessions\n        SET scheduled_time = NOW() + (move_duration || ' seconds')::interval\n        WHERE sessionid = _session_id;\n        PERFORM pg_notify(\n            'game_events',\n            json_build_object(\n                'session_id', _session_id,\n                'event', 'move_timeout',\n                'message', 'Произошел тайм-аут хода',\n                'move_duration', move_duration\n            )::text\n        );\n    ELSE\n        -- Карты закончились: раунд завершен\n        PERFORM score_round(_session_id);\n        -- Очищаем карты на столе, кроме 'Pudding'\n        PERFORM clear_round_table_cards(_session_id);\n        -- Решаем, начать новый раунд или завершить игру\n        IF (SELECT roundnumber FROM gamesessions WHERE sessionid = _session_id) < 3 THEN\n            PERFORM start_new_round(_session_id);\n            SELECT moveduration INTO move_duration FROM gamesessions WHERE sessionid = _session_id;\n            PERFORM cron.schedule(\n                 'session_' || _session_id || '_move_timeout',\n                 move_duration::text || ' seconds',\n                 'SELECT process_move_timeout(' || _session_id || ');'\n            );\n            UPDATE gamesessions\n            SET scheduled_time = NOW() + (move_duration || ' seconds')::interval\n            WHERE sessionid = _session_id;\n        ELSE\n            -- Завершаем игру после 3 раунда\n            PERFORM end_game_session(\n               (SELECT token FROM session_tokens WHERE user_id = \n                   (SELECT userid FROM players WHERE sessionid = _session_id LIMIT 1)\n               ),\n               _session_id\n            );\n        END IF;\n    END IF;\n\n    -- Очищаем отправленные ходы для следующего хода\n    DELETE FROM move_submissions WHERE sessionid = _session_id;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "register_user",
    "description": "Регистрирует нового пользователя, проверяя наличие имени пользователя, хешируя пароль, создавая токен сессии и возвращая JSON-ответ.",
    "parameters": [
      {
        "name": "_username",
        "type": "TEXT",
        "description": "Желаемое имя пользователя."
      },
      {
        "name": "_password",
        "type": "TEXT",
        "description": "Пароль в открытом виде (будет хеширован)."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT register_user('alice', 'abc123');",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Аккаунт успешно создан!\", \"token\": \"550e8400-e29b-41d4-a716-446655440000\" }",
    "code": "CREATE OR REPLACE FUNCTION register_user(_username TEXT, _password TEXT) RETURNS JSON AS $$\nDECLARE\n    new_user_id INT;\n    token UUID;\nBEGIN\n    -- Проверяем, существует ли уже пользователь с таким именем\n    IF EXISTS (SELECT 1 FROM Users WHERE username = _username) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Имя пользователя уже занято'\n        );\n    END IF;\n\n    -- Проверяем длину пароля\n    IF LENGTH(_password) < 3 THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Пароль должен содержать минимум 3 символа'\n        );\n    END IF;\n\n    -- Хешируем пароль и создаем пользователя\n    INSERT INTO Users (username, passwordhash)\n    VALUES (_username, MD5(_password))\n    RETURNING userid INTO new_user_id;\n\n    -- Генерируем уникальный токен сессии\n    token := gen_random_uuid();\n\n    -- Сохраняем токен\n    INSERT INTO session_tokens (user_id, token, created_at)\n    VALUES (new_user_id, token, NOW());\n\n    -- Возвращаем успешный ответ и токен\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Аккаунт успешно создан!',\n        'token', token::UUID\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "name": "reset_password",
    "description": "Сбрасывает пароль пользователя после проверки текущего пароля.",
    "parameters": [
      {
        "name": "user_login",
        "type": "TEXT",
        "description": "Имя пользователя."
      },
      {
        "name": "old_password",
        "type": "TEXT",
        "description": "Текущий пароль пользователя."
      },
      {
        "name": "new_password",
        "type": "TEXT",
        "description": "Новый пароль пользователя."
      }
    ],
    "returns": "JSON",
    "usage": "SELECT reset_password('alice', 'abc123', 'newpass456');",
    "exampleReturns": "{ \"success\": true, \"result_message\": \"Пароль успешно обновлен!\" }",
    "code": "CREATE OR REPLACE FUNCTION reset_password(user_login TEXT, old_password TEXT, new_password TEXT) RETURNS JSON AS $$\nBEGIN\n    -- Проверяем, существует ли пользователь с правильным старым паролем\n    IF NOT EXISTS (\n        SELECT 1 \n        FROM Users \n        WHERE username = user_login AND passwordhash = MD5(old_password)\n    ) THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Неверное имя пользователя или старый пароль'\n        );\n    END IF;\n\n    -- Проверяем длину нового пароля\n    IF LENGTH(new_password) < 3 THEN\n        RETURN json_build_object(\n            'success', FALSE,\n            'result_message', 'Ошибка: Новый пароль должен содержать минимум 3 символа'\n        );\n    END IF;\n\n    -- Обновляем пароль пользователя с новым хешированным паролем\n    UPDATE Users\n    SET passwordhash = MD5(new_password)\n    WHERE username = user_login;\n\n    -- Возвращаем успешный результат\n    RETURN json_build_object(\n        'success', TRUE,\n        'result_message', 'Пароль успешно обновлен!'\n    );\nEND;\n$$ LANGUAGE plpgsql;"
  }
]
